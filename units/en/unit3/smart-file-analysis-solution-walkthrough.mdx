# Module 2: Smart File Analysis - Solution Walkthrough

This walkthrough explains the key implementation details of Module 2's solution.

## Overview

Module 2 enhances the PR Agent by adding MCP Resources - a way to expose read-only data that helps Claude make more informed decisions. While Module 1's Tools let Claude perform actions, Resources provide context.

## Key Implementation Details

### 1. Resource Decorator Pattern

Resources use the `@mcp.resource()` decorator with URI patterns:

```python
@mcp.resource("file://templates/{filename}")
async def read_template(filename: str) -> str:
    """Read a specific PR template file."""
    template_path = TEMPLATES_DIR / filename
    if not template_path.exists():
        return f"Template {filename} not found"
    
    content = template_path.read_text()
    return content
```

Key points:
- URI pattern includes dynamic segment `{filename}`
- Function parameter matches the dynamic segment name
- Returns string content (or error message)
- No side effects - just reading data

### 2. Team Guidelines Resource

```python
@mcp.resource("file://team-guidelines/{filename}")
async def read_team_guidelines(filename: str) -> str:
    """Read team-specific guideline files."""
    guideline_path = TEAM_GUIDELINES_DIR / filename
    if not guideline_path.exists():
        return f"Guideline file {filename} not found"
    
    content = guideline_path.read_text()
    return content
```

Design decision: We use a shared `team-guidelines` directory at the unit level to avoid duplication across modules.

### 3. Git History Resource

```python
@mcp.resource("git://recent-changes")
async def get_recent_changes() -> str:
    """Get recent commit history to understand project patterns."""
    try:
        result = subprocess.run(
            ["git", "log", "--pretty=format:%h|%an|%ae|%ad|%s", "-20", "--date=short"],
            capture_output=True,
            text=True,
            check=True
        )
        
        commits = []
        for line in result.stdout.strip().split('\n'):
            if line:
                parts = line.split('|')
                if len(parts) >= 5:
                    commits.append({
                        "hash": parts[0],
                        "author": parts[1],
                        "email": parts[2],
                        "date": parts[3],
                        "message": parts[4]
                    })
```

Key design choices:
- Custom format string for structured data extraction
- Returns JSON for easy parsing by Claude
- Includes both commit details and statistics

### 4. Team Review Process Resource

```python
@mcp.resource("team://review-process")
async def get_team_review_process() -> str:
    """Get team-specific review process and requirements."""
    process = {
        "pr_size_limits": {
            "small": "< 100 lines: 1 reviewer",
            "medium": "100-500 lines: 2 reviewers",
            "large": "> 500 lines: Split into smaller PRs"
        },
        # ... more structured data
    }
    return json.dumps(process, indent=2)
```

This hardcoded resource demonstrates how team-specific rules can be exposed to Claude.

## URI Design Patterns

The solution uses intuitive URI schemes:
- `file://` - For file-based resources
- `git://` - For git-related data
- `team://` - For team-specific information

This makes resources discoverable and self-documenting.

## Configuration Considerations

### Current Approach (Educational)

```python
TEAM_GUIDELINES_DIR = Path(__file__).parent.parent.parent / "team-guidelines"
```

Hardcoded path for simplicity in the course context.

### Production Approaches

1. **Environment Variables**:
   ```python
   TEAM_GUIDELINES_DIR = Path(os.getenv("PR_AGENT_GUIDELINES_DIR", "./team-guidelines"))
   ```

2. **Configuration File**:
   ```python
   config = load_config()
   TEAM_GUIDELINES_DIR = Path(config.get("guidelines_dir"))
   ```

3. **Auto-detection**:
   ```python
   git_root = subprocess.run(
       ["git", "rev-parse", "--show-toplevel"],
       capture_output=True, text=True
   ).stdout.strip()
   TEAM_GUIDELINES_DIR = Path(git_root) / ".pr-agent"
   ```

## How Claude Uses These Resources

When Claude analyzes PR changes, it can now:

1. **Read team guidelines** to understand coding standards
2. **Analyze recent commits** to match project patterns
3. **Access review processes** to suggest appropriate reviewers
4. **Read individual templates** for detailed structure

Example interaction:
```
User: "What are our Python coding standards?"
Claude: [reads file://team-guidelines/coding-standards.md]
"According to your team's coding standards, you should:
- Use type hints for all functions
- Follow PEP 8 style guide
- Keep line length under 100 characters..."
```

## Testing the Implementation

1. **Manual Testing**: Ask Claude about team guidelines, recent changes, etc.
2. **Resource Discovery**: Use MCP's resource listing to verify all resources are exposed
3. **Error Cases**: Test with non-existent files to ensure graceful handling

## Key Takeaways

1. **Resources vs Tools**: Resources are read-only, Tools perform actions
2. **URI Design**: Use intuitive, hierarchical patterns
3. **Error Handling**: Always handle missing files gracefully
4. **Structure Data**: Return JSON for complex data to help Claude parse it
5. **Shared Resources**: Centralize common resources to avoid duplication

## Next Steps

With Resources in place, Module 3 will add Prompts for standardized workflows, completing the three MCP primitives needed for sophisticated automation.